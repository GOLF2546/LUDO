@main("Ludo Game", "game-page") {
<div class="custom-container">
  <!-- <div id="dice-result" style="font-size: 20px; margin: 20px 0">
    Click the button to roll the dice!
  </div>
  <button onclick="rollDice()">ðŸŽ² Roll Dice</button> -->
  <div class="ludo-board">

    <div class="game-grid">
      <div class="home-base home-base-green">
        <div class="home-square">@components.pawnAtHome(4, "Green")</div>
      </div>

      <div class="path-vertical">@components.path(18, "Yellow")</div>

      <div class="home-base home-base-yellow">
        <div class="home-square">@components.pawnAtHome(4, "Yellow")</div>
      </div>

      <div class="path-horizontal">@components.path(18, "Green")</div>

      <div class="center-star">
        <div id="Y6" class="top-left"></div>
        <div id="B6" class="top-right"></div>
        <div id="G6" class="bottom-left"></div>
        <div id="R6" class="bottom-right"></div>
      </div>

      <div class="path-horizontal">@components.path(18, "Blue")</div>

      <div class="home-base home-base-red">
        <div class="home-square">@components.pawnAtHome(4, "Red")</div>
      </div>

      <div class="path-vertical">@components.path(18, "Red")</div>

      <div class="home-base home-base-blue">
        <div class="home-square">@components.pawnAtHome(4, "Blue")</div>
      </div>
    </div>
  </div>
  <div class="button-container3">
    <img src="@routes.Assets.versioned("images/components/button/homegamepage.png")" alt="home page" class="home-btn"
      onclick="homePage()">
  </div>
</div>
<script>
  // Dice value state
  let diceValue = 0;

  // Navigation function
  function homePage() {
    window.location.href = "@routes.HomeController.index()";
  }

  // Function to roll the dice and display the result
  async function rollDice() {
    try {
      const response = await fetch("@routes.DiceController.rollDice.url", {
        method: "GET",
        headers: {
          Accept: "application/json",
        },
      });
      const result = await response.json();
      diceValue = result;
      document.getElementById("dice-result").innerText = "Dice Roll: " + result;
    } catch (error) {
      console.error("Error rolling dice:", error);
      document.getElementById("dice-result").innerText = "Failed to roll the dice.";
    }
  }

  async function initializeGame() {
    try {
      const response = await fetch("@routes.GameController.startGame.url", {
        method: "GET",
        headers: { Accept: "application/json" },
      });
      const playersData = await response.json();

      // Update player positions based on data
      updatePlayerPositions(playersData);

      // Display simple message instead of raw JSON
      document.getElementById("dice-result").innerText = "Game initialized. Roll the dice to begin!";
    } catch (error) {
      console.error("Error initializing game:", error);
    }
  }

  function updatePlayerPositions(playersData) {
    clearBoardPawn();

    const colorMap = {
      1: "red",
      2: "blue",
      3: "green",
      4: "yellow"
    };

    playersData.forEach(player => {
      const playerId = player.id;
      const color = colorMap[playerId];

      // Process each pawn for this player
      player.pawns.forEach((pawn, pawnIndex) => {
        const pawnId = `${color}-pawn-${pawnIndex}`;

        if (pawn.state === "Start") {
          // Pawn is in home base - nothing to do as they're rendered by the server template
        }
        else if (pawn.state === "Normal") {
          // Pawn is on the board at a specific position
          const cellId = pawn.initialX.toString();
          if (cellId) {
            placePawnOnBoard(cellId, color, pawnId, pawn.state);
          }
        }
        else if (pawn.state === "End") {
          // Pawn has reached the end (could place in center or finish area)
          // For now, we'll place it in the center
          placePawnOnBoard(`${color.charAt(0).toUpperCase()}6`, color, pawnId, pawn.state);
        }
      });
    });
  }

  function clearBoardPawn() {
    const pathSquares = document.querySelectorAll('.path-square');
    pathSquares.forEach(square => {
      // Remove pawn elements but keep the square itself
      const pawns = square.querySelectorAll('.pawn');
      pawns.forEach(pawn => pawn.remove());
    });

    // Clear center star positions
    const centerPositions = ["Y6", "B6", "G6", "R6"];
    centerPositions.forEach(id => {
      const element = document.getElementById(id);
      if (element) element.innerHTML = '';
    });
  }

  function placePawnOnBoard(cellId, color, pawnId, state) {
    const cell = document.getElementById(cellId);
    if (cell) {
      const pawn = document.createElement('div');
      pawn.id = pawnId;
      pawn.className = `pawn ${color}-pawn`;

      // Set the background image
      const imagePath = `/assets/images/components/pawn/${color.charAt(0)}.png`;
      pawn.style.backgroundImage = `url('${imagePath}')`;
      pawn.style.backgroundSize = 'contain';
      pawn.style.backgroundRepeat = 'no-repeat';
      pawn.style.backgroundPosition = 'center';

      if (state === "End") {
        // Pawn at the End: Smaller size & positioned at the bottom of the star
        pawn.style.width = '25%';
        pawn.style.height = '25%';
        pawn.style.position = 'absolute';
        pawn.style.bottom = '5%';
        pawn.style.left = '50%';
        pawn.style.transform = 'translateX(-50%)';

        // Ensure the cell has relative positioning
        cell.style.position = 'relative';
      } else {
        // Normal and Start: Full size, centered
        pawn.style.width = '80%';
        pawn.style.height = '80%';
        pawn.style.borderRadius = '50%';
        pawn.style.margin = 'auto';
      }

      // Add pawn to the cell
      cell.appendChild(pawn);
    }
  }
  // Auto-initialization when DOM content is loaded
  document.addEventListener("DOMContentLoaded", initializeGame);
</script>
}